# JuliaWrapBinary

## No.:
## Title:
## https links: 


1.
Pkg + BinaryBuilder -- The Next Generation
https://julialang.org/blog/2019/11/artifacts/



2.
JLL packages
https://docs.binarybuilder.org/stable/jll/



3.
BinaryBuilder.jl — Using Julia's Pkg to deliver binary libraries
https://pretalx.com/packagingcon-2021/talk/SDEMUJ/



4.
BinaryBuilder.jl
https://docs.binarybuilder.org/stable/



5.
How to use a custom binary
https://jump.dev/JuMP.jl/stable/developers/custom_solver_binaries/



6.
BinaryBuilder.jl is amazing ~ Automatically cross-compile with Docker and convert c and Fortran code into Julia library
https://linuxtut.com/en/46d8c40ae840239b4c1d/



7.
Julia package to wrap a C library
https://discourse.julialang.org/t/julia-package-to-wrap-a-c-library/26749/2

The most popular approach in Julia is to use BinaryBuilder.jl 45 and BinaryProvider.jl 16. Don’t build from source on the end-user’s machine, because that requires the user to have a working C compiler (most people don’t on Mac and Windows) and depends on their environment in a fragile way. And you don’t want to always build the latest git master version, as that might break unexpectedly — you want to build a particular git tag known to work, and update to a newer tag periodically (first testing to make sure the newer version still works).

With BinaryBuilder, you create a separate “builder” package (e.g. xxHashBuilder) with a build script to compile the program. They have set things up so that you can run the build script on Travis CI (automated build/test systems integrated with GitHub), and it will cross-compile binary versions of the library for all the platforms Julia supports, and upload these binaries to a release on your GitHub repo.

Then, in your Julia package (e.g. xxHash.jl), you use BinaryProvider (with a build.jl script that was automatically generated by xxHashBuilder) — when a user installs your package, it will automatically download the pre-built binaries.

When you want to update to a newer upstream version, you update your build script to point to the new release, re-run BinaryBuilder by tagging a new release of xxHashBuilder, and then update your Julia package with the new build.jl file.

You can find various examples of this linked to from the BinaryBuilder documentation. One pretty simple example that I just created is the Xsum.jl 32 package, which wraps Radford Neal’s xsum library 7, building binaries via an xsumBuilder package 23.


https://github.com/JuliaMath/Xsum.jl/blob/master/src/xsum_h.jl


struct xsum_small_accumulator
    chunk::NTuple{67,Int64}
    inf::Int64
    nan::Int64
    adds_until_propagate::Cint
end

struct xsum_large_accumulator
    chunk::NTuple{4096,UInt64}
    count::NTuple{4096,Int16}
    chunks_used::NTuple{64,UInt64}
    used_used::UInt64
    sacc::xsum_small_accumulator
end


for kind in ("xsum_small_", "xsum_large_")
    T = Symbol(kind, "accumulator")
    @eval begin
        $(Symbol(kind,"init"))(acc) =
            ccall(($(QuoteNode(Symbol(kind,"init"))),libxsum), Cvoid, (Ref{$T},), acc)
        $(Symbol(kind,"addv"))(acc, a::StridedVector{Float64}) =
            ccall(($(QuoteNode(Symbol(kind,"addv"))),libxsum), Cvoid, (Ref{$T},Ptr{Float64},Int), acc, a, length(a))


help?> ccall
search: ccall @ccall AbstractChannel
  ccall((function_name, library), returntype, (argtype1, ...), argvalue1, ...)
  ccall(function_name, returntype, (argtype1, ...), argvalue1, ...)
  ccall(function_pointer, returntype, (argtype1, ...), argvalue1, ...)


https://gitlab.com/radfordneal/xsum/-/blob/master/xsum.c

void xsum_small_init (xsum_small_accumulator *restrict sacc)

void xsum_large_init (xsum_large_accumulator *restrict lacc)

void xsum_large_addv (xsum_large_accumulator *restrict lacc,
                      const xsum_flt *restrict vec, 
                      xsum_length n)

void xsum_small_addv (xsum_small_accumulator *restrict sacc, 
                      const xsum_flt *restrict vec, 
                      xsum_length n)



8.
Coupling Julia-based Simulations via preCICE
https://elib.uni-stuttgart.de/bitstream/11682/11853/1/Bachelorthesis_CJBSVP_Kharitenko.pdf

